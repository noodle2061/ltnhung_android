package com.example.nhandientienghet;

import android.Manifest;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.media.AudioAttributes;
import android.media.MediaPlayer;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler; // Import Handler
import android.os.Looper; // Import Looper
import android.os.PowerManager;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.ImageButton; // Import ImageButton
import android.widget.ProgressBar; // Import ProgressBar
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.EdgeToEdge;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

// Thêm thư viện Volley và JSON
import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.toolbox.JsonObjectRequest;
import com.android.volley.toolbox.StringRequest;
import com.android.volley.toolbox.Volley;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;


import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Objects; // Import Objects để kiểm tra null
import java.util.TimeZone;

public class MainActivity extends AppCompatActivity implements MediaPlayer.OnPreparedListener, MediaPlayer.OnErrorListener, MediaPlayer.OnCompletionListener {

    private static final String TAG = "MainActivity";
    public static boolean isActivityVisible;

    // --- Server URLs (Thêm vào đây hoặc lấy từ strings.xml) ---
    // <<< THAY THẾ IP/PORT SERVER CỦA BẠN >>>
    private static final String SERVER_BASE_URL = "http://192.168.56.103:5000";
    private static final String HISTORY_API_URL = SERVER_BASE_URL + "/alert_history";
    private static final String GET_AUDIO_URL_API = SERVER_BASE_URL + "/get_audio_url";
    private static final String VOLLEY_TAG = "MainActivityVolley"; // Tag cho request Volley

    // --- UI Components (Updated) ---
    private TextView tvGreeting;
    // private TextView tvDeviceStatusLabel; // <<< BỎ
    // private TextView tvDeviceStatus;      // <<< BỎ
    private TextView tvLastNoiseTimeLabel;
    private TextView tvLastNoiseTime;
    private ImageButton btnMainPlayPause;
    private ProgressBar progressBarMainAudio;
    private Button btnViewChart;
    private Button btnViewHistory;
    private Button btnStatistics;
    private Button btnEditInfo;

    // --- Broadcast Receivers and Filters ---
    private BroadcastReceiver playAudioReceiver; // Receiver for handling PLAY_AUDIO_NOW
    private IntentFilter playAudioFilter;
    // Token receiver is removed

    // --- MediaPlayer Components for Last Audio ---
    private MediaPlayer lastAudioMediaPlayer; // Player for the audio in the CardView
    private String lastReceivedAudioUrl = null; // URL of the latest audio alert
    private boolean isLastAudioPlaying = false;
    private boolean isLastAudioPrepared = false;
    private Handler lastAudioProgressHandler; // Handler for the CardView's progress bar
    private Runnable lastAudioProgressRunnable; // Runnable for the handler

    // --- Volley Request Queue ---
    private RequestQueue requestQueue;

    // ActivityResultLauncher for requesting POST_NOTIFICATIONS permission
    private final ActivityResultLauncher<String> requestPermissionLauncher =
            registerForActivityResult(new ActivityResultContracts.RequestPermission(), isGranted -> {
                if (isGranted) {
                    Log.i(TAG, "POST_NOTIFICATIONS permission granted.");
                    // You might want to trigger something here if needed after permission grant
                } else {
                    Log.w(TAG, "POST_NOTIFICATIONS permission denied.");
                    showPermissionDeniedDialog();
                }
            });


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, "onCreate");
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_main);

        // --- Initialize Volley Request Queue ---
        requestQueue = Volley.newRequestQueue(this);

        // --- Initialize UI Views (Updated) ---
        tvGreeting = findViewById(R.id.tvGreeting);
        // tvDeviceStatusLabel = findViewById(R.id.tvDeviceStatusLabel); // <<< BỎ
        // tvDeviceStatus = findViewById(R.id.tvDeviceStatus);          // <<< BỎ
        tvLastNoiseTimeLabel = findViewById(R.id.tvLastNoiseTimeLabel);
        tvLastNoiseTime = findViewById(R.id.tvLastNoiseTime);
        btnMainPlayPause = findViewById(R.id.btnMainPlayPause);
        progressBarMainAudio = findViewById(R.id.progressBarMainAudio);
        btnViewChart = findViewById(R.id.btnViewChart);
        btnViewHistory = findViewById(R.id.btnViewHistory);
        btnStatistics = findViewById(R.id.btnStatistics);
        btnEditInfo = findViewById(R.id.btnEditInfo);

        // --- Apply Window Insets ---
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
            return insets;
        });

        // --- Setup Button Click Listeners ---
        btnMainPlayPause.setOnClickListener(v -> togglePlayPauseLastAudio()); // Listener for the new play/pause button
        btnViewChart.setOnClickListener(v -> {
            Log.d(TAG, "View Chart button clicked.");
            Intent chartIntent = new Intent(MainActivity.this, ChartActivity.class);
            startActivity(chartIntent);
        });
        btnViewHistory.setOnClickListener(v -> {
            Log.d(TAG, "View History button clicked.");
            Intent historyIntent = new Intent(MainActivity.this, HistoryActivity.class);
            startActivity(historyIntent);
        });
        btnStatistics.setOnClickListener(v -> {
            Log.d(TAG, "Statistics button clicked.");
            Intent statisticsIntent = new Intent(MainActivity.this, StatisticsActivity.class);
            startActivity(statisticsIntent);
        });
        btnEditInfo.setOnClickListener(v -> {
            Log.d(TAG, "Edit Info button clicked.");
            Intent editInfoIntent = new Intent(MainActivity.this, EditInfoActivity.class);
            startActivity(editInfoIntent);
        });


        // --- Setup Broadcast Receivers ---
        // Token receiver is removed

        // Receiver for immediate audio playback requests (when app is in foreground)
        playAudioReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                String action = intent.getAction();
                Log.d(TAG, "PlayAudioReceiver onReceive triggered with action: " + action);
                if (MyFirebaseMessagingService.ACTION_PLAY_AUDIO_NOW.equals(action)) {
                    String urlToPlay = intent.getStringExtra(MyFirebaseMessagingService.EXTRA_AUDIO_URL);
                    if (urlToPlay != null && !urlToPlay.isEmpty()) {
                        Log.i(TAG, "Received PLAY_AUDIO_NOW broadcast for URL: " + urlToPlay);

                        // Stop background service if it's running
                        stopBackgroundPlaybackService();
                        // Reset any currently playing audio in the main card
                        resetLastAudioPlaybackState();

                        // Store the new URL and update UI
                        lastReceivedAudioUrl = urlToPlay;
                        updateLastNoiseTime(null); // Cập nhật thời gian hiện tại
                        updateAudioControlsVisibility(true); // Make controls visible

                        // Don't auto-play, let the user click the button
                        // initializeAndPlayLastAudio(lastReceivedAudioUrl);

                    } else {
                        Log.w(TAG, "Received PLAY_AUDIO_NOW broadcast without URL.");
                    }
                }
            }
        };
        playAudioFilter = new IntentFilter(MyFirebaseMessagingService.ACTION_PLAY_AUDIO_NOW);

        // --- Initialize Handler for Last Audio Progress ---
        lastAudioProgressHandler = new Handler(Looper.getMainLooper());
        lastAudioProgressRunnable = new Runnable() {
            @Override
            public void run() {
                if (lastAudioMediaPlayer != null && isLastAudioPlaying && isLastAudioPrepared) {
                    try {
                        int currentPosition = lastAudioMediaPlayer.getCurrentPosition();
                        int duration = lastAudioMediaPlayer.getDuration();
                        if (duration > 0) {
                            int progress = (int) (((float) currentPosition / duration) * 100);
                            progressBarMainAudio.setProgress(progress);
                        }
                        // Schedule next update
                        lastAudioProgressHandler.postDelayed(this, 500);
                    } catch (IllegalStateException e) {
                        Log.e(TAG, "IllegalStateException while getting MediaPlayer position/duration for last audio", e);
                        stopLastAudioProgressUpdater();
                    }
                } else {
                    stopLastAudioProgressUpdater();
                }
            }
        };


        // --- Initial Setup ---
        askNotificationPermission();
        // Fetching token is removed

        // <<< QUAN TRỌNG: Xử lý Intent ngay trong onCreate >>>
        // Ưu tiên xử lý URL từ Intent (nếu có) trước khi fetch cái mới nhất
        boolean handledByIntent = handleIntent(getIntent()); // Handle initial intent

        // Cập nhật trạng thái ban đầu (sau khi handleIntent)
        updateAudioControlsVisibility(lastReceivedAudioUrl != null); // Set initial visibility based on handled intent
        // updateDeviceStatus("Chưa xác định"); // <<< BỎ LỜI GỌI NÀY
    }

    // Called when the activity is already running and receives a new intent
    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        Log.d(TAG, "onNewIntent called with intent: " + intent);
        setIntent(intent); // Update the activity's intent
        // <<< QUAN TRỌNG: Xử lý Intent mới ở đây >>>
        handleIntent(intent); // Process the new intent (từ notification khi activity đã chạy)
    }

    /**
     * Processes the intent to extract the audio URL for the main card.
     * @param intent The intent to process.
     * @return true if the intent contained a valid audio URL and was handled, false otherwise.
     */
    private boolean handleIntent(Intent intent) {
        Log.d(TAG, "Handling intent: " + (intent != null ? intent.toString() + " Extras: " + intent.getExtras() : "null"));
        boolean handled = false; // Cờ để biết intent có chứa URL không
        if (intent != null && intent.hasExtra(MyFirebaseMessagingService.EXTRA_AUDIO_URL)) {
            String receivedUrl = intent.getStringExtra(MyFirebaseMessagingService.EXTRA_AUDIO_URL);
            Log.i(TAG, "Received Audio URL from Intent for main card: " + receivedUrl);

            // Luôn dừng service nền nếu mở từ intent có URL (thường là từ notification)
            stopBackgroundPlaybackService();

            // Chỉ cập nhật và reset nếu URL mới thực sự khác URL đang có HOẶC chưa có URL nào
            if (receivedUrl != null && !receivedUrl.isEmpty() && !Objects.equals(receivedUrl, lastReceivedAudioUrl)) {
                Log.d(TAG, "New or different audio URL received via Intent. Resetting state.");
                resetLastAudioPlaybackState(); // Reset playback state cũ
                lastReceivedAudioUrl = receivedUrl; // Cập nhật URL mới
                updateLastNoiseTime(null); // Cập nhật thời gian hiện tại
                updateAudioControlsVisibility(true); // Hiển thị controls cho URL mới
                handled = true; // Đánh dấu đã xử lý URL từ intent
            } else if (receivedUrl != null && !receivedUrl.isEmpty()) {
                // URL giống hệt cái cũ, chỉ cần đảm bảo controls hiển thị
                Log.d(TAG, "Same audio URL received via Intent. Ensuring controls are visible.");
                updateAudioControlsVisibility(true);
                handled = true; // Vẫn coi như đã xử lý vì có URL trong intent
            } else {
                // receivedUrl là null hoặc empty từ intent
                Log.w(TAG, "Intent has EXTRA_AUDIO_URL, but the value is null or empty.");
                // Giữ nguyên trạng thái hiện tại, không reset
                updateAudioControlsVisibility(lastReceivedAudioUrl != null);
                // handled vẫn là false
            }
            // <<< QUAN TRỌNG: Xóa extra khỏi intent sau khi xử lý để tránh xử lý lại >>>
            intent.removeExtra(MyFirebaseMessagingService.EXTRA_AUDIO_URL);

        } else {
            Log.d(TAG, "Intent does not contain EXTRA_AUDIO_URL for main card.");
            // Không làm gì nếu intent không có URL, giữ nguyên trạng thái hiện tại
            updateAudioControlsVisibility(lastReceivedAudioUrl != null);
            // handled vẫn là false
        }
        return handled; // Trả về true nếu intent có URL và đã được xử lý
    }

    @Override
    protected void onStart() {
        super.onStart();
        Log.d(TAG, "onStart - Registering receivers and fetching latest alert");
        isActivityVisible = true;
        // Register local broadcast receiver
        LocalBroadcastManager.getInstance(this).registerReceiver(playAudioReceiver, playAudioFilter);

        // <<< GỌI HÀM LẤY THÔNG TIN MỚI NHẤT KHI ACTIVITY START >>>
        fetchLatestAlertInfo();

        // TODO: Add logic to re-check device status if needed
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop - Unregistering receivers and cancelling Volley requests");
        isActivityVisible = false;
        // Unregister local broadcast receiver
        LocalBroadcastManager.getInstance(this).unregisterReceiver(playAudioReceiver);
        // Hủy các request Volley đang chờ của Activity này để tránh lỗi
        if (requestQueue != null) {
            requestQueue.cancelAll(VOLLEY_TAG);
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause");
        isActivityVisible = false;
        // Pause audio playback if the main card audio is playing
        if (lastAudioMediaPlayer != null && isLastAudioPlaying) {
            try {
                lastAudioMediaPlayer.pause();
                isLastAudioPlaying = false;
                stopLastAudioProgressUpdater();
                btnMainPlayPause.setImageResource(android.R.drawable.ic_media_play);
                Log.i(TAG, "Last audio paused due to Activity pause.");
            } catch (IllegalStateException e) {
                Log.e(TAG, "Error pausing lastAudioMediaPlayer onPause", e);
            }
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume");
        isActivityVisible = true;
        // Stop background service if it was running (có thể dư thừa)
        // stopBackgroundPlaybackService();
        // Don't auto-resume audio, user needs to press play again
        // <<< QUAN TRỌNG: Cập nhật lại visibility phòng trường hợp state thay đổi khi app pause >>>
        updateAudioControlsVisibility(lastReceivedAudioUrl != null);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy");
        isActivityVisible = false;
        stopLastAudioProgressUpdater(); // Stop handler
        releaseLastAudioMediaPlayer(); // Release MediaPlayer resources
        // Không cần hủy request queue ở đây, hủy trong onStop là đủ
    }

    // --- Permission Handling (Keep as is) ---
    private void askNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) ==
                    PackageManager.PERMISSION_GRANTED) {
                Log.i(TAG, "POST_NOTIFICATIONS permission already granted.");
            } else if (shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS)) {
                Log.w(TAG, "Showing rationale for POST_NOTIFICATIONS permission.");
                new AlertDialog.Builder(this)
                        .setTitle(R.string.permission_needed_title)
                        .setMessage(R.string.permission_needed_message)
                        .setPositiveButton(android.R.string.ok, (dialog, which) ->
                                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS))
                        .setNegativeButton(R.string.cancel, (dialog, which) ->
                                Log.w(TAG,"User cancelled permission rationale dialog."))
                        .show();
            } else {
                Log.i(TAG, "Requesting POST_NOTIFICATIONS permission...");
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS);
            }
        } else {
            Log.i(TAG, "POST_NOTIFICATIONS permission not required on this Android version.");
        }
    }

    private void showPermissionDeniedDialog() {
        new AlertDialog.Builder(this)
                .setTitle(R.string.permission_needed_title)
                .setMessage(R.string.permission_needed_message)
                .setPositiveButton(R.string.settings, (dialog, which) -> {
                    Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
                    Uri uri = Uri.fromParts("package", getPackageName(), null);
                    intent.setData(uri);
                    startActivity(intent);
                })
                .setNegativeButton(R.string.cancel, (dialog, which) -> dialog.dismiss())
                .show();
    }

    // --- FCM Token Handling (Removed) ---
    // fetchCurrentToken() method is removed

    // --- Main Card Audio Player Handling ---

    private void togglePlayPauseLastAudio() {
        if (lastReceivedAudioUrl == null || lastReceivedAudioUrl.isEmpty()) {
            Toast.makeText(this, R.string.no_audio_url, Toast.LENGTH_SHORT).show();
            Log.w(TAG, "No last audio URL available to play.");
            updateAudioControlsVisibility(false);
            return;
        }

        // Ensure the background playback service is stopped
        stopBackgroundPlaybackService();

        if (lastAudioMediaPlayer != null && isLastAudioPlaying) {
            // If playing, pause it
            try {
                lastAudioMediaPlayer.pause();
                isLastAudioPlaying = false;
                stopLastAudioProgressUpdater();
                btnMainPlayPause.setImageResource(android.R.drawable.ic_media_play);
                Log.i(TAG, "Last audio paused.");
            } catch (IllegalStateException e) {
                Log.e(TAG, "Error pausing lastAudioMediaPlayer", e);
                handleLastAudioError("Lỗi khi tạm dừng");
            }
        } else if (lastAudioMediaPlayer != null && isLastAudioPrepared) {
            // If prepared but paused, resume playback
            try {
                lastAudioMediaPlayer.start();
                isLastAudioPlaying = true;
                startLastAudioProgressUpdater();
                btnMainPlayPause.setImageResource(android.R.drawable.ic_media_pause);
                Log.i(TAG, "Last audio resumed.");
            } catch (IllegalStateException e) {
                Log.e(TAG, "Error resuming lastAudioMediaPlayer", e);
                handleLastAudioError("Lỗi khi tiếp tục phát");
            }
        } else {
            // If not prepared or null, initialize and start playback
            initializeAndPlayLastAudio(lastReceivedAudioUrl);
        }
    }

    private void initializeAndPlayLastAudio(String url) {
        resetLastAudioPlaybackState(); // Release any existing player instance first
        Log.i(TAG, "Initializing lastAudioMediaPlayer for URL: " + url);
        updateAudioControlsVisibility(true); // Ensure controls are visible
        progressBarMainAudio.setProgress(0); // Reset progress
        btnMainPlayPause.setEnabled(false); // Disable button while preparing
        btnMainPlayPause.setImageResource(android.R.drawable.ic_media_play); // Show play icon

        Toast.makeText(this, R.string.audio_preparing, Toast.LENGTH_SHORT).show();

        lastAudioMediaPlayer = new MediaPlayer();
        lastAudioMediaPlayer.setAudioAttributes(
                new AudioAttributes.Builder()
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .build()
        );
        try {
            lastAudioMediaPlayer.setWakeMode(getApplicationContext(), PowerManager.PARTIAL_WAKE_LOCK);
        } catch (SecurityException e) {
            Log.w(TAG, "Missing WAKE_LOCK permission for lastAudioMediaPlayer", e);
        }

        try {
            lastAudioMediaPlayer.setDataSource(url);
            // Use the activity itself as the listener
            lastAudioMediaPlayer.setOnPreparedListener(this);
            lastAudioMediaPlayer.setOnErrorListener(this);
            lastAudioMediaPlayer.setOnCompletionListener(this);
            lastAudioMediaPlayer.prepareAsync();
            Log.i(TAG, "lastAudioMediaPlayer preparing...");
        } catch (IOException | IllegalArgumentException | SecurityException | IllegalStateException e) {
            Log.e(TAG, "Error initializing lastAudioMediaPlayer", e);
            handleLastAudioError(String.format(getString(R.string.error_playing_audio), e.getMessage()));
        }
    }

    // --- MediaPlayer Listener Callbacks (for lastAudioMediaPlayer) ---

    @Override
    public void onPrepared(MediaPlayer mp) {
        // Check if this callback is for the lastAudioMediaPlayer
        if (mp == lastAudioMediaPlayer) {
            Log.i(TAG, "lastAudioMediaPlayer prepared.");
            isLastAudioPrepared = true;
            btnMainPlayPause.setEnabled(true); // Enable the play/pause button
            try {
                mp.start();
                isLastAudioPlaying = true;
                startLastAudioProgressUpdater(); // Start progress updates
                btnMainPlayPause.setImageResource(android.R.drawable.ic_media_pause); // Update button icon
                Log.i(TAG, "Last audio playback started.");
            } catch (IllegalStateException e) {
                Log.e(TAG, "IllegalStateException on lastAudioMediaPlayer.start()", e);
                handleLastAudioError(String.format(getString(R.string.error_playing_audio), "Lỗi khi bắt đầu phát"));
            }
        } else {
            Log.w(TAG, "onPrepared called for an unknown MediaPlayer instance.");
        }
    }

    @Override
    public boolean onError(MediaPlayer mp, int what, int extra) {
        // Check if this callback is for the lastAudioMediaPlayer
        if (mp == lastAudioMediaPlayer) {
            Log.e(TAG, "lastAudioMediaPlayer Error: what=" + what + ", extra=" + extra);
            String errorMsg = getMediaPlayerErrorString(what, extra);
            handleLastAudioError(String.format(getString(R.string.error_playing_audio), errorMsg));
            return true; // Indicate error handled
        } else {
            Log.w(TAG, "onError called for an unknown MediaPlayer instance.");
            return false; // Indicate error not handled
        }
    }

    @Override
    public void onCompletion(MediaPlayer mp) {
        // Check if this callback is for the lastAudioMediaPlayer
        if (mp == lastAudioMediaPlayer) {
            Log.i(TAG, "lastAudioMediaPlayer playback completed.");
            resetLastAudioPlaybackState(); // Reset state on completion
            Toast.makeText(this, R.string.audio_completed, Toast.LENGTH_SHORT).show();
        } else {
            Log.w(TAG, "onCompletion called for an unknown MediaPlayer instance.");
        }
    }

    // --- Helper Methods for Last Audio Player ---

    private void releaseLastAudioMediaPlayer() {
        if (lastAudioMediaPlayer != null) {
            Log.d(TAG, "Releasing lastAudioMediaPlayer.");
            try {
                if (lastAudioMediaPlayer.isPlaying()) {
                    lastAudioMediaPlayer.stop();
                }
                lastAudioMediaPlayer.reset();
                lastAudioMediaPlayer.release();
            } catch (IllegalStateException e) {
                Log.e(TAG, "IllegalStateException during lastAudioMediaPlayer release", e);
            } finally {
                lastAudioMediaPlayer = null;
                isLastAudioPrepared = false;
                isLastAudioPlaying = false;
                Log.i(TAG, "lastAudioMediaPlayer released.");
            }
        }
    }

    // Resets the state related to the main card's audio playback
    private void resetLastAudioPlaybackState() {
        Log.d(TAG, "Resetting last audio playback state.");
        releaseLastAudioMediaPlayer();
        stopLastAudioProgressUpdater();
        // Update UI on the main thread
        runOnUiThread(() -> {
            if (btnMainPlayPause != null) {
                btnMainPlayPause.setImageResource(android.R.drawable.ic_media_play);
                // Keep button enabled if URL exists, disable otherwise
                // <<< SỬA LỖI: Không nên dựa vào lastReceivedAudioUrl ở đây vì nó có thể chưa được cập nhật >>>
                // <<< Tạm thời disable, sẽ enable lại khi có URL mới hoặc khi fetch thành công >>>
                btnMainPlayPause.setEnabled(false);
                // btnMainPlayPause.setEnabled(lastReceivedAudioUrl != null && !lastReceivedAudioUrl.isEmpty());
            }
            if (progressBarMainAudio != null) {
                progressBarMainAudio.setProgress(0);
                // Keep visibility based on URL existence
                // <<< SỬA LỖI: Ẩn đi khi reset >>>
                progressBarMainAudio.setVisibility(View.INVISIBLE);
                // progressBarMainAudio.setVisibility( (lastReceivedAudioUrl != null && !lastReceivedAudioUrl.isEmpty()) ? View.VISIBLE : View.INVISIBLE);
            }
        });
    }


    // Centralized handler for lastAudioMediaPlayer errors
    private void handleLastAudioError(String logMessageForUser) {
        Log.e(TAG, "lastAudioMediaPlayer Error: " + logMessageForUser);
        resetLastAudioPlaybackState(); // Reset state on error
        // Show a user-friendly error message
        runOnUiThread(() -> {
            Toast.makeText(MainActivity.this, logMessageForUser, Toast.LENGTH_LONG).show();
            // Ensure controls are appropriately enabled/disabled after error
            updateAudioControlsVisibility(false); // <<< SỬA LỖI: Luôn ẩn controls khi có lỗi >>>
            // updateAudioControlsVisibility(lastReceivedAudioUrl != null);
        });
    }

    // Helper method to convert MediaPlayer error codes to strings (Keep as is)
    private String getMediaPlayerErrorString(int what, int extra) {
        String whatError;
        switch (what) {
            case MediaPlayer.MEDIA_ERROR_UNKNOWN: whatError = "MEDIA_ERROR_UNKNOWN"; break;
            case MediaPlayer.MEDIA_ERROR_SERVER_DIED: whatError = "MEDIA_ERROR_SERVER_DIED"; break;
            default: whatError = "Error code: " + what;
        }
        String extraError;
        switch (extra) {
            case MediaPlayer.MEDIA_ERROR_IO: extraError = "MEDIA_ERROR_IO"; break;
            case MediaPlayer.MEDIA_ERROR_MALFORMED: extraError = "MEDIA_ERROR_MALFORMED"; break;
            case MediaPlayer.MEDIA_ERROR_UNSUPPORTED: extraError = "MEDIA_ERROR_UNSUPPORTED"; break;
            case MediaPlayer.MEDIA_ERROR_TIMED_OUT: extraError = "MEDIA_ERROR_TIMED_OUT"; break;
            case -2147483648: extraError = "MEDIA_ERROR_SYSTEM (-2147483648)"; break;
            default: extraError = "Extra code: " + extra;
        }
        return whatError + " (" + extraError + ")";
    }

    // --- Progress Updater Handling for Last Audio ---
    private void startLastAudioProgressUpdater() {
        stopLastAudioProgressUpdater(); // Stop previous one if any
        lastAudioProgressHandler.post(lastAudioProgressRunnable);
        Log.d(TAG, "Started last audio progress updater.");
    }

    private void stopLastAudioProgressUpdater() {
        lastAudioProgressHandler.removeCallbacks(lastAudioProgressRunnable);
        Log.d(TAG, "Stopped last audio progress updater.");
    }

    // --- UI Update Helpers ---

    // Updates the visibility of play/pause button and progress bar
    private void updateAudioControlsVisibility(boolean show) {
        runOnUiThread(() -> {
            // Sử dụng final để đảm bảo giá trị không đổi trong lambda
            // <<< SỬA LỖI: Kiểm tra lastReceivedAudioUrl TRƯỚC KHI quyết định hiển thị >>>
            final boolean shouldShowControls = show && (lastReceivedAudioUrl != null && !lastReceivedAudioUrl.isEmpty());
            int visibility = shouldShowControls ? View.VISIBLE : View.INVISIBLE; // Use INVISIBLE to maintain layout space
            Log.d(TAG, "updateAudioControlsVisibility: showParam=" + show + ", lastReceivedAudioUrl=" + lastReceivedAudioUrl + ", final visibility=" + (visibility == View.VISIBLE ? "VISIBLE" : "INVISIBLE"));

            if (btnMainPlayPause != null) {
                btnMainPlayPause.setVisibility(visibility);
                // Chỉ enable nút khi nó hiển thị VÀ media player không phải đang chuẩn bị
                btnMainPlayPause.setEnabled(shouldShowControls && (lastAudioMediaPlayer == null || isLastAudioPrepared));
            }
            if (progressBarMainAudio != null) {
                progressBarMainAudio.setVisibility(visibility);
                if (!shouldShowControls) {
                    progressBarMainAudio.setProgress(0); // Reset progress when hiding
                }
            }
        });
    }


    /**
     * Updates the last noise time display.
     * @param isoTimestamp Optional ISO 8601 timestamp string. If null, uses current time.
     */
    private void updateLastNoiseTime(@androidx.annotation.Nullable String isoTimestamp) {
        runOnUiThread(() -> {
            if (tvLastNoiseTime != null) {
                String formattedTime;
                if (isoTimestamp != null) {
                    formattedTime = formatDisplayTimestamp(isoTimestamp); // Format timestamp từ server
                } else if (lastReceivedAudioUrl != null) {
                    // Nếu không có timestamp từ server nhưng có URL, dùng giờ hiện tại
                    SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault());
                    formattedTime = sdf.format(new Date());
                } else {
                    formattedTime = getString(R.string.last_noise_time_none);
                }
                tvLastNoiseTime.setText(formattedTime);
            }
        });
    }


    // Bỏ phương thức updateDeviceStatus
    /*
    private void updateDeviceStatus(String status) {
        runOnUiThread(() -> {
            if (tvDeviceStatus != null) {
                tvDeviceStatus.setText(status);
                // TODO: Change text color based on status (e.g., green for online, red for offline)
            }
        });
    }
    */


    // --- Background Service Control (Keep as is) ---
    private void stopBackgroundPlaybackService() {
        Log.d(TAG, "Requesting to stop AudioPlaybackService.");
        Intent stopIntent = new Intent(this, AudioPlaybackService.class);
        stopIntent.setAction(AudioPlaybackService.ACTION_STOP);
        stopService(stopIntent);
    }

    // --- Network Request Methods ---

    /**
     * Fetches the latest alert information from the server.
     */
    private void fetchLatestAlertInfo() {
        String url = HISTORY_API_URL + "?limit=1"; // Request only the latest item
        Log.d(TAG, "Fetching latest alert info from: " + url);

        JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(
                Request.Method.GET, url, null,
                response -> {
                    Log.d(TAG, "Latest history response received: " + response.toString());
                    try {
                        String status = response.getString("status");
                        if ("success".equals(status)) {
                            JSONArray historyArray = response.getJSONArray("history");
                            if (historyArray.length() > 0) {
                                // Lấy item đầu tiên (mới nhất)
                                JSONObject latestItem = historyArray.getJSONObject(0);
                                String s3Key = latestItem.optString("s3_key", null);
                                String timestamp = latestItem.optString("timestamp", null); // Lấy timestamp

                                if (s3Key != null && !s3Key.isEmpty()) {
                                    Log.i(TAG, "Latest alert has s3_key: " + s3Key + ", timestamp: " + timestamp);
                                    // Nếu URL hiện tại khác với URL sắp lấy, hoặc chưa có URL nào
                                    // thì mới tiến hành lấy URL mới và reset state
                                    // (Tránh fetch lại URL nếu s3_key không đổi)
                                    // <<< Cần so sánh s3_key thay vì URL vì URL có thể thay đổi >>>
                                    // <<< Tạm thời luôn fetch URL mới khi có s3_key >>>
                                    fetchAudioUrlFromKey(s3Key, timestamp); // Truyền timestamp vào
                                } else {
                                    // Mục mới nhất không có audio
                                    Log.i(TAG, "Latest alert has no s3_key. Timestamp: " + timestamp);
                                    // Chỉ cập nhật thời gian, không reset audio player, ẩn controls
                                    updateLastNoiseTime(timestamp);
                                    lastReceivedAudioUrl = null; // Đảm bảo không có URL cũ
                                    updateAudioControlsVisibility(false);
                                }
                            } else {
                                // Không có lịch sử nào trên server
                                Log.i(TAG, "No alert history found on server.");
                                updateLastNoiseTime(null); // Hiển thị "Chưa có"
                                lastReceivedAudioUrl = null;
                                updateAudioControlsVisibility(false);
                            }
                        } else {
                            String message = response.optString("message", "Unknown server success error");
                            Log.e(TAG, "Server returned success=false fetching history: " + message);
                            Toast.makeText(MainActivity.this, "Lỗi server lấy lịch sử", Toast.LENGTH_SHORT).show();
                        }
                    } catch (JSONException e) {
                        Log.e(TAG, "Error parsing latest history JSON response", e);
                        Toast.makeText(MainActivity.this, "Lỗi xử lý dữ liệu lịch sử", Toast.LENGTH_SHORT).show();
                    }
                },
                error -> {
                    Log.e(TAG, "Volley error fetching latest history: " + error.toString());
                    Toast.makeText(MainActivity.this, "Lỗi mạng lấy lịch sử", Toast.LENGTH_SHORT).show();
                });

        jsonObjectRequest.setTag(VOLLEY_TAG); // Gắn tag để có thể hủy
        requestQueue.add(jsonObjectRequest);
    }

    /**
     * Fetches the pre-signed audio URL from the server using the S3 key.
     * @param s3Key The S3 key of the audio file.
     * @param alertTimestamp The timestamp of the alert (optional, for updating UI).
     */
    private void fetchAudioUrlFromKey(String s3Key, @androidx.annotation.Nullable String alertTimestamp) {
        String apiUrl = GET_AUDIO_URL_API + "?s3_key=" + Uri.encode(s3Key);
        Log.d(TAG, "Fetching S3 URL from: " + apiUrl);

        StringRequest stringRequest = new StringRequest(Request.Method.GET, apiUrl,
                response -> {
                    Log.d(TAG, "S3 URL response: " + response);
                    try {
                        JSONObject jsonResponse = new JSONObject(response);
                        String status = jsonResponse.getString("status");
                        if ("success".equals(status)) {
                            String presignedUrl = jsonResponse.getString("url");
                            Log.i(TAG, "Got pre-signed URL: " + presignedUrl);

                            // <<< Chỉ reset và cập nhật nếu URL mới khác URL cũ >>>
                            if (!Objects.equals(presignedUrl, lastReceivedAudioUrl)) {
                                Log.d(TAG, "New audio URL fetched. Resetting state.");
                                resetLastAudioPlaybackState(); // Reset trước khi cập nhật URL mới
                                lastReceivedAudioUrl = presignedUrl;
                                updateLastNoiseTime(alertTimestamp); // Cập nhật thời gian từ alert
                                updateAudioControlsVisibility(true); // Hiển thị controls
                            } else {
                                Log.d(TAG, "Fetched URL is the same as the current one. No state reset needed.");
                                // Đảm bảo controls vẫn hiển thị nếu URL không đổi
                                updateLastNoiseTime(alertTimestamp);
                                updateAudioControlsVisibility(true);
                            }
                        } else {
                            String message = jsonResponse.optString("message", "Failed to get URL");
                            Log.e(TAG, "Server error getting S3 URL: " + message);
                            Toast.makeText(MainActivity.this, getString(R.string.audio_error_url) + ": " + message, Toast.LENGTH_LONG).show();
                            // Nếu không lấy được URL, ẩn controls
                            lastReceivedAudioUrl = null;
                            updateAudioControlsVisibility(false);
                            updateLastNoiseTime(alertTimestamp); // Vẫn cập nhật thời gian của alert
                        }
                    } catch (JSONException e) {
                        Log.e(TAG, "Error parsing S3 URL JSON response", e);
                        Toast.makeText(MainActivity.this, R.string.audio_error_url_parsing, Toast.LENGTH_LONG).show();
                        lastReceivedAudioUrl = null;
                        updateAudioControlsVisibility(false);
                        updateLastNoiseTime(alertTimestamp);
                    }
                },
                error -> {
                    Log.e(TAG, "Volley error fetching S3 URL: " + error.toString());
                    Toast.makeText(MainActivity.this, R.string.audio_error_url_network, Toast.LENGTH_LONG).show();
                    lastReceivedAudioUrl = null;
                    updateAudioControlsVisibility(false);
                    updateLastNoiseTime(alertTimestamp);
                });

        stringRequest.setTag(VOLLEY_TAG); // Gắn tag
        requestQueue.add(stringRequest);
    }

    // --- Timestamp Formatting Helper ---
    /**
     * Formats an ISO 8601 timestamp string into a displayable format (dd/MM/yyyy HH:mm:ss).
     * Returns the original string if parsing fails.
     * @param isoTimestamp The ISO 8601 timestamp string.
     * @return Formatted string or the original string on error.
     */
    private String formatDisplayTimestamp(String isoTimestamp) {
        if (isoTimestamp == null) return getString(R.string.last_noise_time_none);
        // Các định dạng có thể nhận được từ Firestore hoặc server
        SimpleDateFormat[] possibleInputFormats = {
                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSSSS'Z'", Locale.US), // UTC with microseconds
                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US),        // UTC without microseconds
                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSSSSXXX", Locale.US),// Offset with microseconds
                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX", Locale.US),       // Offset without microseconds
                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US)            // Simple ISO format assumed UTC if no offset
        };
        // Set TimeZone cho các định dạng UTC
        possibleInputFormats[0].setTimeZone(TimeZone.getTimeZone("UTC"));
        possibleInputFormats[1].setTimeZone(TimeZone.getTimeZone("UTC"));
        possibleInputFormats[4].setTimeZone(TimeZone.getTimeZone("UTC")); // Assume UTC if no offset info

        Date date = null;
        for (SimpleDateFormat format : possibleInputFormats) {
            try {
                date = format.parse(isoTimestamp);
                if (date != null) break; // Stop if parsing succeeds
            } catch (ParseException e) {
                // Try next format
            }
        }

        if (date != null) {
            SimpleDateFormat outputFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault());
            // Output theo múi giờ địa phương của thiết bị
            outputFormat.setTimeZone(TimeZone.getDefault());
            return outputFormat.format(date);
        } else {
            Log.w(TAG, "Could not parse timestamp: " + isoTimestamp);
            return isoTimestamp; // Trả về chuỗi gốc nếu không parse được
        }
    }

    // ---------------------------------
}
